x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: 基礎暗号学講座・第12回 ～素数生成アルゴリズム～ ---

著者：IPUSIRON

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　数学において素数は重要な存在である。数学と密接な関係にある暗号の世界に
おいても、素数は重要な存在である。公開鍵暗号スキームのアルゴリズムの仕様
を確認してもらえれば、多くの場合において素数をランダムに選択する必要があ
ることがわかると思う。例えば、RSA暗号（WB34参照）の鍵生成アルゴリズムでは
大きな素数を2つ生成しなければならない。この部分できちんとした素数が作られ
なければ、暗号の安全性が脆弱になってしまうのである。つまり、素数をランダ
ムに生成するということは暗号の世界において重要と言える。
　今回の記事では、素数をランダムに生成するアルゴリズム（以降、素数生成ア
ルゴリズムと呼ぶことにする）を単に紹介するだけでは面白くないので、試行錯
誤しながら素数生成アルゴリズムを考えていくことにする。その後、いくつかの
素数生成アルゴリズムを紹介し、コストの面（必要となる速度・メモリ）の観点
で比較する。最後に、指定されたビット数の素数の生成について言及する。


■0x02.) 素数生成アルゴリズム＝ランダム値生成アルゴリズム＋素数テスト

　前回のWB35では原始元生成アルゴリズムを紹介した。その際、確定的に（100%
の確率で）原始元を生成するアルゴリズムを作るよりも、ある程度大きな確率で
原始元を生成するアルゴリズムを作る方が効率がよいという話をした。このある
程度大きな確率で原始元を生成するアルゴリズムというのは、ランダムな値を生
成するアルゴリズムと、原始元判定アルゴリズムの組み合わせであった。

　今回の素数生成アルゴリズムも、同様のアプローチで考えた方が高速であるこ
とがわかっている。つまり、素数生成アルゴリズムを考える上で重要な部分は、
優秀な素数判定アルゴリズムを考えるという点に帰着される。素数生成アルゴリ
ズムの一部として利用できるぐらい優秀な素数判定アルゴリズムのことを素数テ
ストを呼ぶことにする。

　まず、素数テストを定義しなければならない。次の2つの条件を満たすようなア
ルゴリズムのことを素数テストと呼ぶ。

・入力が合成数（素数でない値）だった場合、acceptまたはrejectを出力する。
ただし、acceptする確率は1/2以下とする。
・入力が素数だった場合、必ずacceptを出力する。

　つまり、素数テストに素数でない値が入力されれば1/2以上の確率でrejectされ、
素数が入力されれば必ずacceptされるということである。

　理想的なアルゴリズムはaccept（素数と判定）されたものは必ず素数で、reje
ct（素数でない）と判定されたものは必ず素数でないものである。しかし、この
理想的なものがないとしても、上記の定義のような素数テストさえ存在すれば、
このアルゴリズムを何度も繰り返すことで素数でないのにaccpet（素数と判定）
される可能性はどんどん低くすることができる。つまり、実質的に素数テストを
多段で使ってaccpet（素数と判定）されたものはほとんど素数と考えてよいとい
える。


■0x03.) フェルマーテスト

　まず素朴に考えると、素数テストのアルゴリズムとして、フェルマーの小定理
が使えるかもしれないと思うはずである。それでは本当に使えるのかどうかを確
認してみよう。

　フェルマーの小定理とは「pが素数ならば、任意のa（∈{1,…,p}）に対してa^
{p-1}≡1 (mod p)が成り立つ」というものであった。つまり、pが素数ならば、p
-1乗すればどの値でもmod pの世界で1に一致するということである。

　これを素数pの代わりに、一般の整数n（素数と合成数の混合）に対して考えて
みる。ここで、aはn以下の整数なら何でもよいので、a=4としておく。

[1]n=5のとき

・4^{n-1}=4^{5-1}=4^4=16×16≡1×1 (mod 5)=1

[2]n=6のとき

・4^{n-1}=4^{6-1}=4^5≡4 (mod 6)

[3]n=7のとき

・4^{n-1}=4^{7-1}=4^6≡1 (mod 7)

[4]n=8のとき

・4^{n-1}=4^{8-1}=4^7≡0 (mod 8)

[5]n=9のとき

・4^{n-1}=4^{9-1}=4^8≡7 (mod 9)

[6]n=10のとき

・4^{n-1}=4^{10-1}=4^9≡4 (mod 10)

[7]n=11のとき5

・4^{n-1}=4^{11-1}=4^10≡1 (mod 11)

[8]n=12のとき

・4^{n-1}=4^{12-1}=4^11≡4 (mod 12)

　nが素数のときに4^{n-1} (mod n)が1になることは、フェルマーの小定理から当
然である。この表から、逆に4^{n-1} (mod n)が1のときに、nは素数に対応してい
ることがわかる。例えば、n=5,7,11（すべて素数）のときに4^{n-1} (mod n)が1
に一致しているからである。即ち、フェルマーの小定理の逆が成り立つことが期
待できそうである（対偶が成り立つのは自明。ここではさらに逆が成り立つこと
を期待している）。このフェルマーの小定理の逆の方法で、素数判定アルゴリズ
ムをフェルマーテストと呼び、フェルマーテストのアルゴリズム名をFermatとす
る。このFermatの入出力と内部のアルゴリズムは次のようになる。

・入力：n：整数（ただし、n≧3）
・出力："reject" or "accept"

-----  Fermatのアルゴリズム
a←{2,3,…,n-2}からランダムに選択した値
if a^{n-1} ≠ 1 (mod n) then
    return "reject"
else return "accept"
-----

　ここで、nが素数ならば、「Fermat(n)="reject"」（この表記法は「Fermatにn
を代入したときの出力結果が"reject"」ということを意味する）となる確率は0が
当然成り立つ。一方、nが合成数ならば、「Fermat(n)="reject"」がどんな値にな
るかが不明である。1になるのが理想的だが、それは難しそうである。しかし何ら
かの確率が具体的に出て欲しい。できれば1/2以上だと嬉しい（1/2以上なら素数
テストとして活用可能であることが確定するから）。それでは、「nが合成数」か
つ「Fermat(n)="reject"」が成り立つときの確率を調べてみる。

　ここで主張を明確にするために、次の2つの言葉を定義する。

・「n≧2」かつ「a^{n-1}≠1 (mod n)」が成り立つとき、a（ただし1≦a＜n）を
「nに対するFermat witness」と呼ぶ。
・「n（≧3）：合成数」かつ「a^{n-1}≡1 (mod n)」が成り立つとき、a（ただし
1≦a＜n）を「nに対するFermat liar」と呼ぶ。

　この定義より、指定されたnに対してひとつでもFermat witnessが存在したら、
nは合成数と確定できる。なぜならば、Fermat witnessということは「a^{n-1}≠
1 (mod n)」が成り立つことを意味し、Fermatのアルゴリズムのif文の条件文に対
応している。つまり、if文の条件がTrueになり、"reject"が出力されることに対
応する。ところが、nが素数のときに"reject"が出力されることは皆無である。こ
れはフェルマーの小定理から明らかである。つまり、"reject"が出力されたとき
のFermatの入力は必ず合成数ということになる。

　また、「nが合成数」かつ「Fermat(n)="reject"」が成り立つときの確率を調べ
るには、aの総数のうちで、「nに対するFermat witness」であるようなaの個数が
どれぐらいあるかを知ることができればよい。まず、aの総数はn-3個である。こ
れはaは3≦a＜nを満たすから明らかである。次に、「nに対するFermat witness」
のときは、定義より「a^{n-1}≠1 (mod n)」という条件が満たされたときである。

　そして、nが素数か否か、aが指定されたnにおいてa^{n-1}≡1 (mod n)を満たす
か否かによって分類すると、次の4つのパターンが存在する。

-------------------------------------------------------
|                               | nは素数 | nは合成数 |
|-----------------------------------------------------|
| aがa^{n-1}≠1 (mod n)を満たす |   (1)   |   (2)     |
|-----------------------------------------------------|
| aがa^{n-1}≡1 (mod n)を満たす |   (3)   |   (4)     |
-------------------------------------------------------

　フェルマーの小定理より、(1)の場合はありえないので、0個。そして、aが「n
に対するFermat witness」であるときの個数は(2)、aが「nに対するFermat liar」
であるときの個数は(3)+(4)に対応している。つまり、「nに対するFermat witne
ss」＋「nに対するFermat liar」＝n-3が成り立つ。先ほど、「nが合成数」かつ
「Fermat(n)="reject"」が成り立つときのaの個数が、nに対するFermat witness
の個数と一致するとすでに述べた。よって、「nが合成数」かつ「Fermat(n)="re
ject"」が成り立つときのaの個数は、「aの総数」-「nに対するFermat liar」と
言い換えることもできる。
　以上のことをまとめると、目的であった「nが合成数」かつ「Fermat(n)="reje
ct"」が成り立つときの確率は（nに対するFermat witnessの個数）/（n-3）、即
ち1-（nに対するFermat liarの個数）/（n-3）である。

　ランダム値生成アルゴリズムでnを生成するわけだが、例えばn=143を生成して、
これを素数判定アルゴリズムFermatに入力したときの動きを見ていく。そもそも
n=143は11×13のように素因数分解できるので、合成数である。しかし、我々はま
だ合成数かどうかわからない、これを調べるためにFermatを使うのである。n=14
3のときの「nに対するFermat liar」、即ちa^{n-1}≡1 (mod n)を満たすようなa
を知りたい。ここでは結論を述べると、a=1,12,131,142の4つだけである。例えば、
143は合成数なので、12^142 (mod 143)は1に一致するとは限らない。ところが計
算すると1に一致する。131も同様に131^142≡1 (mod 143)が成り立つので、143に
対するFermat liarのひとつである。特にa=1（なぜならば1^142≡1 (mod 143)）,
142（なぜならば142^142≡-1^142 (mod 143)≡1 (mod 143)）は自明なものなので、
除外して考えると、a=12,131だけになる。
　このとき「Fermat(143)="reject"」が成り立つ確率が1/2以上かどうかを調べる。
まず、「Fermat(143)="accept"が成り立つ確率」＝2/(143-3)=2/140=1/70＜1/2が
成り立つ。よって、「Fermat(143)="reject"が成り立つ確率」＞1/2になる。つま
り、n=143のときはFermatを多段にすることで、合成数を判断できてうまくはじく
ことができるわけだ。　◇

　次に、n=561のときを考えてみる。このn=561も3×11×17と素因数分解できるの
で合成数である。
　このとき「Fermat(561)="reject"」が成り立つ確率が1/2以上かどうかを調べる。
n=561のときにGCD(a,n)=1を満たすaは「nに対するFermat liar」になってしまう。
つまり、「Fermat(143)="accept"が成り立つ確率」＝φ(n)/(n-3)≒φ(n)/nにな
る（φという記号はオイラー関数を意味する）。なぜφ(n)が出てくるのかという
と、GCD(a,n)=1であるようなaの個数、即ちZ_n^*の個数だからである。よって、
「Fermat(143)="reject"が成り立つ確率」＝(1-φ(n))/nになる。ここで、nが大
きいとき、n-φ(n)＜＜nが成り立つので、「Fermat(143)="reject"が成り立つ確
率」＜＜1/2になってしまう。つまり、n=561のときはFermatを多段にしても、合
成数を判断できずうまくはじくことができない。つまり、n=561に対してはFerma
tは、素数テストとしてうまく動かないということである。　◇

　このようなnはカーマイケル数と呼ばれ、無限に存在することが証明されている。
よって、例外となるのはn=561だけでなく、ランダム値生成アルゴリズムの出力で
あるnでたまたまカーマイケル数が選ばれてしまえばFermatは素数テストとして有
効ではないということになる。しかも、カーマイケル数は無限に存在するので、
nがカーマイケル数かどうかをチェックしてから、Fermatの入力にするというアプ
ローチも無理である。したがって、フェルマーテストは素数テストとして活用は
できないという結論になる。


■0x04.) カーマイケル数

　この節ではカーマイケル数についてもう少し見てみる。素数生成アルゴリズム
の話からは少しはずれるので、飛ばしてもらってもよい。

　カーマイケル数には次のような性質を持つ。

[定理]（Alford, Graville and Pomerance (1992)）
カーマイケル数は無限個存在する。

[証明]論文読んでないから、証明わからない。後日読んでおく…。

[定理]「n（≧3）：奇数のカーマイケル」
⇔「次の3つすべてが成り立つ。
・nは平行数を持たない
・任意のnがpと素である
・p-1がn-1の約数」

[証明]⇔を示すので、必要条件と十分条件に場合分けして証明する。

[1]⇒を示す

　カーマイケル数の定義より、(n,a)=1を満たすような任意のaに対して、a^{n-1}
≡1 (mod n)が成り立つ。

　また、pをnの約数の素数とし、aをnと素なmod pの原始元とする。このaは、中
国人の剰余定理?より存在が保証される。すると、原始元の定義より、a^{p-1}≡
1 (mod p)が成り立つ。よって、a^{n-1}≡1 (mod p)が成り立つ。

　次に、[定理]「g∈Gであり、e∈Zであるとする。このとき、g^e=1となるのは、
eがgの位数で割り切れるときに限る」より、aの位数p-1はn-1の約数である。

　さらに、p^2がnの約数でないことを示す。背理法を用いるため、p^2がnを割り
切ると仮定する。このとき、φ(p^2)（=(p-1)p）はφ(n)の約数である。また、m
od nの既約剰余群で位数pの元が存在する。よって、pはn-1の約数である。これは
pがnの約数であることに矛盾する。

[2]←を示す

　nは平方数を含まないとし、nのすべての素の約数pに対して、p-1をn-1の約数と
する。ただし、aとnは互いに素とする。

　このとき、フェルマーの小定理より、a^{p-1}≡1 (mod p)が成り立つ。n-1はp
-1の倍数であるから、a^{n-1}≡1 (mod p)が成り立つ（nと素である値pごとに、
このリレーションが成り立つ）。よって、nの素因数は互いに異なっているから、
a^{n-1}≡1 (mod n)が成り立つ（複数のリレーションをひとつのリレーションに
まとめた）。　□


[定理]カーマイケル数は少なくとも3つの異なる素因数を持つ。

[証明]nをカーマイケル数とすると、定義よりnは素数ではない。また、上記の定
理より、nは平方数を持たない。よって、nは素数のべき乗にはならない。つまり、
nは少なくとも2つの素因数を持つことがいえる。

　次に、p,q（p＞qとしても一般性を失わない）をnの素因数とし、n=pqが成り立
つと仮定する。上記の定理より、p-1はn-1=pq-1=(p-1)q+(q-1)の約数になる。よ
って、p-1はq-1の約数となる。しかし、p＞qより、p-1＞q-1（＞0）が成り立つの
で、q-1の最小性より矛盾が生じる。よって、n=pqと仮定したことが間違いという
ことになる。したがって、nの素因数は少なくとも3つ以上であることがいえる。　□


■0x05.) Miller-Rabinテスト

　Millerの定理と呼ばれる次の定理が存在する。

[定理]pを素数とし、rはp-1={2^s}×rを満たす奇数とする（奇数が出るまで2で割
っている）。
このとき、1≦a≦p-1なる任意の整数aに対して、次が成り立つ。
「a^r≡1 (mod p)」あるいは「a^{{2^j}×r}≡-1 (mod p)」を満たすようなj∈{
0,…,s-1}が存在する。←(*)

　ここではMillerの定理の証明はせずに、何を意味しているのか、そしてなぜ成
り立つのかという点と直観的に述べる。

　pが素数のとき、「x^2≡1 (mod p)」⇒「x≡-1 or 1」が成り立つ。pが合成数
のときはこれが成り立つとは限らない。よって、素数を法とする世界で2乗して1
だったら、元の数は1 or -1である。つまり、a^rを2乗ずつしていき、1に初めて
なったとき、その直前の数は-1でなければならないということである（図1参照）。

（図1）http://security2600.sakura.ne.jp/main2/image3/miller1.jpg

　Millarの定理を利用した素数テストであるMiller-Rabinテスト（MRテスト）を
紹介する。このMiller-Rabinテストの入出力とアルゴリズムMRは次のようになる。

・入力：n（n≧3の奇数）
・出力："prime" or "composite"

-----  MRのアルゴリズム
s,rはn-1=2^{s}×rを満たすようにセットされる（ただし、rは奇数）
i=0
i←i+1
a：{1,2,…,n-1}からランダムに選択
y[0]←a^r mod n
if(y[0]==1 || y[0] == n-1)
    output "prime"
else
    for(j=1;j≦s-1;j=j+1){
        y[j]←y[j-1]^2 mod n
        if(y[j]==n-1)
            output "prime"
    }
output "composite"
-----

　MRのアルゴリズムの中身について解説する。

・6行目のif文の条件式の前半はMillerの定理の「a^r≡1」に対応し、後半はj=0
のときの「a^{{2^j}×r}≡1」に対応する。y[0]==n-1はmod nでy[0]=-1であるこ
とに注意。

・11行目のif文の条件式はj≠0のときのa^{{2^j}×r}≡1に対応する。

　このMiller-Rabinテストの問題は次の2点である。

・入力nが素数なのに、"composite"と出力されること→[1]
・入力nが合成数なのに、"prime"と出力されること→[2]

[1]nが素数の場合

　Millerの定理より、MRは"composite"を出力しない。なぜならば、いきなり1に
なるか、途中で-1が出てくるかのどちらかである。よって、必ず「output "prim
e"」の命令にひっかかる。

[2]nが偶数の場合

　Miller-Rabinテストで、"prime"を出力する確率は(1/4)^tになる。ただし、tは
繰り返し回数とする。

　以上でMiller-Rabinテストの仕様についての解説は終えた。

　Miller-Rabinテストでは、「nが合成数」かつ「MR(n)="reject"」が成り立つと
きの確率が1/2以上であることを期待したい。ここで主張を明確にするために、次
の2つの言葉を定義する。

・「a^r≠1 (mod n)」かつ「任意のj∈{0,…,k-1}において、a^{{2^s}×r}≠-1 
(mod n)」が成り立つとき、aを「nに対するMR-witness」と呼ぶ。
・「n：合成数」かつ「a：nのMR-witnessでない」が成り立つとき、aを「nに対す
るMR-liar」と呼ぶ。

　Fermat-wintess/liarのときの議論と同様に、「nに対するMR-witness」と「nに
対するMR-liar」も次の関係式が成り立つ。

「nに対するMR-witness」＋「nに対するMR-liar」＝n-1

例1：意味と使い方に慣れることを目的として、Miller-Rabinテストを用いること
によって、n=105が素数かどうかを判定してみる（n=105=3・5・7が成り立つので
本当は素数ではないのだが、それは気にせずアルゴリズム的にどう動くか調べる）。

　n-1=104={2^3}×13が成り立つから、まずs=3,r=13とセットされる。次に、ラン
ダムに選んだ整数値がa=8であったとする。すると、y[0]=8^{13}≡8 (mod 105)に
なる。このy[0]はmod 105の世界で1 or 104(=n-1)ではないので、else以下のfor
文が実行される。

・y[1]←y[0]^2≡8^2≡64 (mod 105)
・y[2]←y[1]^2≡64^2≡1 (mod 105)

　後は、ずっとy[j]は1 (mod 105)になる。そのため「output "prime"」が実行さ
れずに、最終的に「output "composite"」が実行される。よって、n=105は素数で
はない。　◇

例2：次にカーマイケル数が入力されても、Miller-Rabinテストがうまく動作する
ことを確認する。ここでは例として最小のカーマイケル数であるn=561=3×11×1
7を考える。先ほどのフェルマーテストではこのときに問題があった。Miller-Ra
binテストではこの問題が解決されていることを確認しておかなければならない。

　n-1=560={2^4}×35が成り立つので、s=4,r=35とセットされる。

・a=2
・a^35=2^35 (mod 561)≡263
・a^70=166
・a^140=67　←a^280=1となる直前だが、mod nの世界では-1ではない
・a^280=1
・a^560=1

　a=2のとき、a^rの2乗ずつしていくと、a^{n-1}までに法nの世界で-1は一度も登
場しない。つまり、a=2はMR-witnessになる（n=561にはMR-witnessが少なくとも
ひとつ存在することが確認できた）。

　同様に、a=3,…,560まで調べていくと、例えばa=5のときは「nに対するMR-wit
ness」になるし、a=50のときは「nに対するMR-liar」になる。よって、n=561のと
きにMR-witnessとMR-liarがあることがわかった。実際には、（MR-witnessの数）
＞（MR-liarの数）であることがわかっている。よって、「MR(561)="reject"」が
成り立つ確率は1/2以上になる。以上により、カーマイケル数の一種であるn=561
であっても、Miller-Rabinテストは素数テストとしてうまく働くことが確認でき
た。

　最後に気になるのは、どのような整数nを選んだとしても、「nが合成数」かつ
「MR(n)="reject"」が成り立つ確率が1/2以上であるかどうかという点である。こ
の疑問に関しては肯定的な意味で解決されている。それを定理としてまとめると
次のようになる。

[定理]「nが合成数」かつ「MR(n)="reject"」が成り立つ確率が1/2以上である。
言い換えると、「nが合成数」かつ「MR(n)="accept"」が成り立つ確率は1/2より
小さい。

[証明]nを合成数とする。「nに対するMR-liar」であるようなaの個数が、全体の
半分以下であることを示すことができればよい。ここで、全体とはZ_n^*なので、
その個数はφ(n)である。

　まず、nがカーマイケル数か否かによって場合分けして考える。

[1]nがカーマイケル数でないとき

　nがカーマイケル数でなければフェルマーテストであっても問題なかった。Mil
ler-Rabinテストはフェルマーテストの改良版なので、アルゴリズム的に問題なく、
次の関係（集合の包含関係）が成り立つ。

（「nに対するMR-liar」であるようなaの集まり）
⊆（「nに対するFermat-liar」であるようなaの集まり）
＜Z_n^*

　よって、「nに対するMR-liar」であるようなaの集まりの要素の個数は1/2×φ
(n)以下である。

[2]nがカーマイケル数であるとき

　問題はこちらの場合である。「nに対するMR-liar」（a^{{2^s}×r}≡-1 (mod 
n)）であるようなaの集まりのままでは考えにくいので、これを包括するような集
合を新たに考え、その集合であってもZ_n^*の真部分群であることを示すことがで
きればよい。a^{{2^s}×r}≡-1 (mod n)を満たすようなaの集まりをAとする。ま
た、tをa^{{2^s}×r}≡1 (mod n)を満たすようなaが存在するときにおける、sの
最大値とする。このtを使って、新しい集合を、a^{{2^t}×r}≡±1 (mod n)を満
たすようなaの集まりと定義できる。この集合をBとする。A⊆Bであることに注意。
目的はB＜Z_n^*を示すことである。真部分群であることを示すには、部分群であ
ることと真の部分群であることの2つを示せばよい。この2つを順を追って証明し
ていく。

(i)BがZ_n^*の部分群であることを示す

　部分群であることを示すためには逆元の存在と演算が閉じていることをいえれ
ばよい。

・Bは逆元が存在する。なぜならば、b^{{2^t}×r}≡±1 (mod n)を満たす値であ
るbは、2乗すれば必ず1に一致する。つまり、逆元は必ず存在するからである（自
分自身）。
・c,d∈Bならば、cd∈Bが成り立つ。なぜならば、c,d∈Bより、cはc^{{2^t}×r}
≡±1 (mod n)を満たす値、dはd^{{2^t}×r}≡±1 (mod n)を満たす値である。よ
って、{cd}^{{2^t}×r}≡±1 (mod n)が成り立つので、cd∈Bが成り立つ。一言で
言えば、±1をを掛ければ、結局±1になるからである。

　よって、B≦Z_n^*が成り立つ。

(i)BがZ_n^*の真部分群であることを示す

　これを示せば、Z_n^*からBを除いた集合が空集合であればよい。そこで背理法
を用いる。そこで、Z_n^*からBを除いた集合が空集合でないと仮定する。

　カーマイケル数は3つ以上の素因子を持つので、少なくともn=n_1×n_2と記述さ
れる。ただし、n_1,n_2とも奇数かつGCD(n_1,n_2)=1である。

　また、{{2^t}×r}乗するとmod nの世界で-1に一致するような値がAの要素に存
在する（これはAの定義から明らか）。この値をeとする。つまり、e^{{2^t}×r}
≡-1 (mod n)が成り立つ。

　ここで、a:=e (mod n_1)と定義する。すると、中国人の剰余定理より、次の連
立合同式を満たすようなa∈Zが存在する。

・a≡e (mod n_1)
・a≡1 (mod n_2)
・ただし、GCD(n_1,n_2)=1

　まず、「a^{{2^t}×r}≡e^{{2^t}×r} (mod n_1)≡-1 (mod n_1)」（この結果
を①とする）が成り立つ。また、「a^{{2^t}×r}≡1 (mod n_1)」（この結果を②
とする）も成り立つ。

　よって、a^{{2^t}×r}≡1と考えると②に反し、a^{{2^t}×r}≡-1と考えると①
に反するので、a^{{2^t}×r}≠±1 (mod n)になる（modがnになっていることに注
意）。よって、a（∈Z_n^*）はBに属しない。

　そもそもA⊆Bのように設定したはずなのに、aはAに含まれ、Bに含まれないとい
うことはありえない。よって、矛盾が生じた。　□

　これでMiller-Rabinテストが素数テストとして有効であることが示された。

　後は、「nが合成数」かつ「MR(n)="accept"」が成り立つ確率がどのくらいの値
以下であるかどうかを評価できれば嬉しい。これがわかれば、どのくらい多段に
すれば十分かどうかを正確にわかる。
　証明は省くが、確率として次のような結果が知られている。

[定理]「nが合成数」かつ「MR(n)="accept"」が成り立つ確率は1/4以下である。

　MR(n)をk回独立に繰り返した全体をMR_k(n)とする。MR_k(n)は内部でk回MR(n)
をサブルーチンとして呼び出す。MR(n)がすべて"accept"ならばMR_k(n)も"accep
t"、MR(n)がひとつでも"reject"ならばMR_k(n)は"reject"とする。つまり、1回で
も"reject"が出力されたら、MR_k(n)も"accept"ということになる。

　よって、次の定理が得られる。

[定理]「nが合成数」かつ「MR_k(n)="accept"」が成り立つ確率は(1/4)^k以下で
ある。

[証明]MR_k(n)は内部でシーケンシャル、しかもk個それぞれが独立にMR(n)をサブ
ルーチンとして呼び出すので、全体の確立は(1/4)^k以下となる。　□


■0x06.) Miller-Rabinテストと他の素数生成アルゴリズムとの比較

　Wikipedeia（http://ja.wikipedia.org/wiki/素数判定）を参照してもらえれば
わかるように、素数生成アルゴリズムにはいくつか種類が存在する。その中に確
率的な素数判定アルゴリズムとして、Miller-RabinテストやSolovay-Strassenテ
ストがある。まだルジャンドルの記号をWBで定義していないことと、Miller-Rab
inテストの方が計算量が小さいので、Solovay-Strassenテストのアルゴリズムに
ついては今回言及しない。とりあえずMiller-Rabinテストを知っておけば暗号の
実装はなんとかなると思う。


■0x07.) 素数のランダムな選択

　Miller-Rabinテストなどで効率的に素数を生成できることは示されたが、まだ
固定されたビット長の素数の生成についてはまだ言及していない。実際に多くの
暗号スキームの鍵生成アルゴリズムなどでは、固定されたビット長のランダムな
素数を生成する必要が生じる。

　ここではkビットの素数を生成したいとする。そのとき、次の手順で実行すれば
よい。

1：kビットの奇数nをランダムに生成する。ただし、nの最初と最後のビットを1と
おき、残りのk-2ビットの数をそれぞれ独立でランダムに生成する。

2：このnが素数かどうかを調べる。

　最初に素数表を使用して、nがある一定の値であるBよりも小さい素数で割り切
れるかどうかを調べる。利用するハードウェアやソフトウェアがMiller-Rabinテ
ストでの割り算をどのくらい速いかによって、このBの値は決定される。Miller-
Rabinテストより、試行割算法の方がずっと効率的な場合は、より大きなBを選ぶ
とよい。一般的な例として、B=106と選ばれる。nの約数が見つからなければ、以
降を実行する。

　次に、k回の繰り返しのMiller-RabinテストのアルゴリズムMR_kにnを入力する。
ここでnのMR-witnessが見つからなければ、nは素数である。見つからなければ、
nは合成数であるので、ステップ1に戻ってやり直す。

3：最終的に得られたnはkビットの素数とみなせる。


■0x08.) 終わりに

　今月号の記事で暗号の実装における道具が大体揃った。後は多倍長演算さえあ
ればよい。多倍長演算はちょっと複雑なので、ちょっと飛ばすことにする（実装
するときは既存のライブラリを使うか、Rubyのように多倍長演算を自動的にして
くれるスクリプト言語を使うとよいかもしれない）。
　次回からはまた暗号技術についての解説に戻る。個人的にはすぐにデジタル署
名に入りたいが、その前にハッシュ関数について言及する。なぜならデジタル署
名の安全性を高める手法として、ハッシュ関数を利用する方法があるからである。
また、UNIXのパスワード認証におけるパスワードファイルや、掲示板のトリップ、
配布プログラムの改竄チェックなどのように、コンピュータの世界における幅広
い場面でもハッシュ関数は利用されている。こうした理由によりハッシュ関数に
ついて理解を深めておくことは有用と思われるので、早めに解説しようと思いま
した。

　では、また来月会いましょう。



